<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>D2Q9</title>
</head>

<body>

    <canvas id="canvas" style="max-width: 100%;">
    </canvas>

    <div id="fps" style="font-family: monospace">0 fps</div>

    <div
        style="font-family: monospace; display: flex; justify-content: space-around; flex-direction: column; align-items: center;">
        <div
            style="display: flex; flex-direction: row; align-items: center; justify-content: space-around; width: 75%; max-width: 600px;">
            <span style="padding-right: 0.8em; display: flex; flex-direction: row; align-items: center">
                $\tau\,\,$ <input type="range" id="slider_tau" min="0.6" max="5" step="0.1" />
            </span>
            <span>
                <button id="reset_button" onclick="reset()">Reset</button>
            </span>
        </div>
    </div>

    <script type="module">
        // see: https://users.rust-lang.org/t/error-importing-wasm-wasm-bindgen-for-web-error/83370/3
        //      https://rustwasm.github.io/docs/wasm-bindgen/examples/without-a-bundler.html
        // import init, { D1Q3, wasm_memory } from "/wasm/lbm_1d/static/wasm_lbm.js";
        import init, { D2Q9, wasm_memory } from "./static/wasm_lbm.js";

        await init();

        const ch = 500;
        const cw = 500;
        const nx = 120;
        const ny = nx;

        var temp = 1.00;
        var tau = 1;

        const steps_per_frame = 15;

        var lbm;
        var rho;
        var vel;

        var prev_time = 0;

        function vmag(x, y) {
            return Math.sqrt(x * x + y * y);
        }

        function vclip(x, y, l) {
            const l_ = vmag(x, y);

            if (l_ > l) {
                x = (x / l_) * l;
                y = (y / l_) * l;

            }

            return [x, y];
        }

        async function run() {

            lbm = D2Q9.new(nx, ny);

            rho = new Float32Array(wasm_memory().buffer, lbm.rho_(), nx * ny);
            vel = new Float32Array(wasm_memory().buffer, lbm.vel_(), nx * ny * 2);

            function add_gauss_rho(arr, xloc, yloc, std, scale) {
                for (let i = 0; i < nx; i++) {
                    for (let j = 0; j < ny; j++) {
                        const x2 = (i - xloc) * (i - xloc) + (j - yloc) * (j - yloc);
                        arr[i + j * nx] += scale * Math.exp(-x2 / (std * std));
                    }
                }
            }

            function add_gauss_vel(arr, xloc, yloc, vx, vy, std, scale) {
                for (let i = 0; i < nx; i++) {
                    for (let j = 0; j < ny; j++) {
                        const idx = i + j * nx;
                        const x2 = vmag(i - xloc, j - yloc);
                        let vx_ = arr[0 + 2 * idx] + vx * scale * Math.exp(-x2 * x2 / (std * std));
                        let vy_ = arr[1 + 2 * idx] + vy * scale * Math.exp(-x2 * x2 / (std * std));
                        // vx_, vy_ = vclip(vx, vy, 0.0001);
                        arr[0 + 2 * idx] = vx_;
                        arr[1 + 2 * idx] = vy_;
                    }
                }
            }
            function rescale(arr, avg_val) {
                let sum = 0.0;
                for (let i = 0; i < nx; i++) {
                    sum += arr[i];
                }
                sum /= nx;
                for (let i = 0; i < nx; i++) {
                    arr[i] *= (avg_val / sum);
                }
            }

            lbm.reinit(temp);

            const canvas = document.getElementById("canvas");
            const ctx = canvas.getContext("2d");

            canvas.addEventListener("click", event => {
                const boundingRect = canvas.getBoundingClientRect();

                const scaleX = canvas.width / boundingRect.width;
                const scaleY = canvas.height / boundingRect.height;

                const canvasLeft = (event.clientX - boundingRect.left) * scaleX;
                const canvasTop = (event.clientY - boundingRect.top) * scaleY;

                const x = (canvasLeft / cw) * nx;
                const y = (canvasTop / ch) * ny;

                add_gauss_rho(rho, x, y, 10, 0.2);
                rescale(rho, 1.0);

                lbm.reinit(temp);
            });

            canvas.addEventListener("mousemove", event => {
                const boundingRect = canvas.getBoundingClientRect();

                const scaleX = canvas.width / boundingRect.width;
                const scaleY = canvas.height / boundingRect.height;

                const canvasLeft = (event.clientX - boundingRect.left) * scaleX;
                const canvasTop = (event.clientY - boundingRect.top) * scaleY;

                const x = (canvasLeft / cw) * nx;
                const y = (canvasTop / ch) * ny;

                let vx = event.movementX * scaleX;
                let vy = event.movementY * scaleY;

                const [vx_, vy_] = vclip(vx, vy, 25.0);

                add_gauss_vel(vel, x, y, vx_, vy_, 3, 0.01);
                lbm.reinit(temp);
            });

            canvas.height = ch;
            canvas.width = cw;

            const drawPlot = (time) => {

                const dt_ms = time - prev_time;
                const dt_sec = dt_ms / 1000.0;
                const fps = Math.floor(1 / dt_sec);
                prev_time = time;

                document.getElementById("fps").textContent = fps + " fps";

                ctx.clearRect(0, 0, cw, ch)

                // --- Draw the current state.

                const dx = cw / nx;
                const dy = ch / ny;

                const vm = 0.05;

                for (let i = 0; i < nx; i++) {
                    for (let j = 0; j < ny; j++) {
                        ctx.beginPath();
                        const idx = i + j * nx;
                        const vx = vel[0 + 2 * idx];
                        const vy = vel[1 + 2 * idx];
                        const v2 = vmag(vx, vy);
                        // const f = (rho[idx] - 0.99) / 0.02; // TODO: clamp (0, 1)

                        // const fx = (vel[0 + 2 * idx] / vm + 1) / 2;
                        // const fy = (vel[1 + 2 * idx] / vm + 1) / 2;
                        // const r = Math.floor(255 * fx);
                        // const b = Math.floor(255 * fy);
                        // const g = 0;
                        // ctx.fillStyle = `rgb(${r} ${g} ${b})`

                        const theta = Math.atan2(vy, vx);
                        const h = Math.floor(360 * theta / (2 * Math.PI));
                        const s = Math.floor(100 * Math.min(v2 / vm, 1.0));
                        const l = Math.floor(60 - 10 * (s / 100));
                        ctx.fillStyle = `hsl(${h}deg ${s}% ${l}%)`

                        ctx.fillRect(
                            Math.floor(i * dx),
                            Math.floor(j * dy),
                            Math.ceil(dx),
                            Math.ceil(dy),
                        );
                    }
                }

                // --- Update the simulation.

                lbm.step_n(tau, steps_per_frame);

                // --- Trigger the next frame.

                requestAnimationFrame(drawPlot);
            }

            requestAnimationFrame(drawPlot);
        }

        function reset() {
            for (let i = 0; i < nx; i++) {
                for (let j = 0; j < ny; j++) {
                    const idx = i + j * nx;
                    rho[idx] = 1.0;
                    vel[0 + 2 * idx] = 0.0;
                    vel[1 + 2 * idx] = 0.0;
                }
            }
            lbm.reinit();
        }

        document.getElementById("reset_button").addEventListener("click", reset);
        document.getElementById("slider_tau").addEventListener("input", (event) => {
            tau = event.target.value;
        });

        run();
    </script>


</body>

</html>